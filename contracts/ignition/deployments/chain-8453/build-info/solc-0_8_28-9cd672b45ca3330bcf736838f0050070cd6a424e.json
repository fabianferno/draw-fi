{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-9cd672b45ca3330bcf736838f0050070cd6a424e",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/LineFutures.sol": "project/contracts/LineFutures.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/LineFutures.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @title LineFutures\n * @notice Gamified futures trading platform where users predict token price movements over 60 seconds\n * @dev PNL is calculated based on directional accuracy using a Point-by-Point Directional Method\n */\ncontract LineFutures {\n    // Position structure\n    struct Position {\n        address user;                      // User's wallet address\n        uint256 amount;                    // Deposited amount (in wei)\n        uint16 leverage;                   // 1x to 2500x\n        uint256 openTimestamp;             // Block timestamp when opened\n        string predictionCommitmentId;     // EigenDA commitment for predictions (full commitment)\n        bool isOpen;                       // Position status\n        int256 pnl;                        // Calculated PNL (in wei)\n        string actualPriceCommitmentId;    // EigenDA commitment for actual prices (full commitment)\n        uint256 closeTimestamp;            // Block timestamp when closed\n    }\n\n    // State variables\n    mapping(uint256 => Position) public positions;\n    mapping(address => uint256[]) public userPositions;\n    uint256 public positionCounter;\n    address public owner;\n    address public pnlServer;\n\n    // Constants\n    uint256 public constant MIN_AMOUNT = 10**15;          // 0.001 ETH minimum\n    uint16 public constant MAX_LEVERAGE = 2500;\n    uint256 public constant POSITION_DURATION = 60;       // seconds\n\n    // Fee system\n    uint256 public collectedFees;\n    uint256 public feePercentage = 200;                   // 2% = 200 basis points (out of 10000)\n\n    bool public paused;\n\n    // Events\n    event PositionOpened(\n        uint256 indexed positionId,\n        address indexed user,\n        uint256 amount,\n        uint16 leverage,\n        uint256 timestamp,\n        string predictionCommitmentId\n    );\n\n    event PositionClosed(\n        uint256 indexed positionId,\n        address indexed user,\n        int256 pnl,\n        uint256 finalAmount,\n        string actualPriceCommitmentId,\n        uint256 timestamp\n    );\n\n    event FeesWithdrawn(address indexed owner, uint256 amount, uint256 timestamp);\n    event PnLServerUpdated(address indexed oldServer, address indexed newServer);\n    event FeePercentageUpdated(uint256 oldFee, uint256 newFee);\n    event ContractPaused();\n    event ContractUnpaused();\n\n    // Modifiers\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"LineFutures: caller is not the owner\");\n        _;\n    }\n\n    modifier onlyPnLServer() {\n        require(msg.sender == pnlServer, \"LineFutures: caller is not the PnL server\");\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused, \"LineFutures: contract is paused\");\n        _;\n    }\n\n    /**\n     * @notice Constructor sets the initial owner and PnL server\n     * @param _pnlServer Address authorized to close positions\n     */\n    constructor(address _pnlServer) {\n        require(_pnlServer != address(0), \"LineFutures: PnL server is zero address\");\n        \n        owner = msg.sender;\n        pnlServer = _pnlServer;\n        \n        emit PnLServerUpdated(address(0), _pnlServer);\n    }\n\n    /**\n     * @notice Open a new position\n     * @param _leverage Leverage multiplier (1-2500)\n     * @param _predictionCommitmentId EigenDA commitment ID for user predictions (full commitment string)\n     * @return positionId The ID of the newly created position\n     */\n    function openPosition(\n        uint16 _leverage,\n        string memory _predictionCommitmentId\n    ) external payable whenNotPaused returns (uint256 positionId) {\n        // Validate inputs\n        require(msg.value >= MIN_AMOUNT, \"LineFutures: amount below minimum\");\n        require(_leverage >= 1 && _leverage <= MAX_LEVERAGE, \"LineFutures: invalid leverage\");\n        require(bytes(_predictionCommitmentId).length > 0, \"LineFutures: empty commitment ID\");\n\n        // Create new position\n        Position memory newPosition = Position({\n            user: msg.sender,\n            amount: msg.value,\n            leverage: _leverage,\n            openTimestamp: block.timestamp,\n            predictionCommitmentId: _predictionCommitmentId,\n            isOpen: true,\n            pnl: 0,\n            actualPriceCommitmentId: \"\",\n            closeTimestamp: 0\n        });\n\n        // Store position\n        positionId = positionCounter;\n        positions[positionId] = newPosition;\n        userPositions[msg.sender].push(positionId);\n        positionCounter++;\n\n        emit PositionOpened(\n            positionId,\n            msg.sender,\n            msg.value,\n            _leverage,\n            block.timestamp,\n            _predictionCommitmentId\n        );\n\n        return positionId;\n    }\n\n    /**\n     * @notice Batch open 1-5 positions with equal ETH split and staggered timestamps\n     * @param _leverage Leverage multiplier (1-2500) applied to all positions\n     * @param _predictionCommitmentIds Array of 1-5 EigenDA commitment IDs for predictions\n     * @return positionIds Array of position IDs for the newly created positions\n     * @dev Each position receives an equal share of msg.value (msg.value / count)\n     * @dev Positions are staggered by 60 seconds: position i opens at block.timestamp + i * 60\n     */\n    function batchOpenPositions(\n        uint16 _leverage,\n        string[] memory _predictionCommitmentIds\n    ) external payable whenNotPaused returns (uint256[] memory positionIds) {\n        uint256 count = _predictionCommitmentIds.length;\n        \n        // Validate position count (1-5)\n        require(count >= 1 && count <= 5, \"LineFutures: invalid position count\");\n        \n        // Validate leverage\n        require(_leverage >= 1 && _leverage <= MAX_LEVERAGE, \"LineFutures: invalid leverage\");\n        \n        // Validate total ETH amount\n        require(msg.value >= MIN_AMOUNT * count, \"LineFutures: total amount below minimum\");\n        \n        // Calculate amount per position (equal split)\n        uint256 amountPerPosition = msg.value / count;\n        require(amountPerPosition >= MIN_AMOUNT, \"LineFutures: amount per position below minimum\");\n        \n        // Refund remainder if any (to avoid dust stuck in contract)\n        uint256 remainder = msg.value % count;\n        if (remainder > 0) {\n            (bool success, ) = payable(msg.sender).call{value: remainder}(\"\");\n            require(success, \"LineFutures: remainder refund failed\");\n        }\n        \n        // Initialize return array\n        positionIds = new uint256[](count);\n        \n        // Create positions with staggered timestamps\n        for (uint256 i = 0; i < count; i++) {\n            // Validate commitment ID is not empty\n            require(\n                bytes(_predictionCommitmentIds[i]).length > 0,\n                \"LineFutures: empty commitment ID\"\n            );\n            \n            // Calculate staggered timestamp: block.timestamp + i * 60 seconds\n            uint256 openTimestamp = block.timestamp + (i * POSITION_DURATION);\n            \n            // Create new position\n            Position memory newPosition = Position({\n                user: msg.sender,\n                amount: amountPerPosition,\n                leverage: _leverage,\n                openTimestamp: openTimestamp,\n                predictionCommitmentId: _predictionCommitmentIds[i],\n                isOpen: true,\n                pnl: 0,\n                actualPriceCommitmentId: \"\",\n                closeTimestamp: 0\n            });\n            \n            // Store position\n            uint256 positionId = positionCounter;\n            positions[positionId] = newPosition;\n            userPositions[msg.sender].push(positionId);\n            positionIds[i] = positionId;\n            positionCounter++;\n            \n            // Emit event for each position\n            emit PositionOpened(\n                positionId,\n                msg.sender,\n                amountPerPosition,\n                _leverage,\n                openTimestamp,\n                _predictionCommitmentIds[i]\n            );\n        }\n        \n        return positionIds;\n    }\n\n    /**\n     * @notice Close a position (called by PnL server)\n     * @param _positionId Position ID to close\n     * @param _pnl Calculated PNL in wei (can be negative)\n     * @param _actualPriceCommitmentId EigenDA commitment ID for actual prices (full commitment string)\n     */\n    function closePosition(\n        uint256 _positionId,\n        int256 _pnl,\n        string memory _actualPriceCommitmentId\n    ) external onlyPnLServer {\n        // Validate position exists\n        require(_positionId < positionCounter, \"LineFutures: position does not exist\");\n        \n        Position storage position = positions[_positionId];\n        \n        // Validate position state\n        require(position.isOpen, \"LineFutures: position already closed\");\n        require(\n            block.timestamp >= position.openTimestamp + POSITION_DURATION,\n            \"LineFutures: position not yet closable\"\n        );\n        require(bytes(_actualPriceCommitmentId).length > 0, \"LineFutures: empty commitment ID\");\n\n        // Update position data\n        position.pnl = _pnl;\n        position.actualPriceCommitmentId = _actualPriceCommitmentId;\n        position.isOpen = false;\n        position.closeTimestamp = block.timestamp;\n\n        // Calculate fee (only on profits)\n        uint256 fee = 0;\n        if (_pnl > 0) {\n            fee = (uint256(_pnl) * feePercentage) / 10000;\n            collectedFees += fee;\n        }\n\n        // Calculate final payout\n        int256 finalAmount = int256(position.amount) + _pnl - int256(fee);\n\n        // Transfer funds to user if positive\n        uint256 transferAmount = 0;\n        if (finalAmount > 0) {\n            transferAmount = uint256(finalAmount);\n            (bool success, ) = payable(position.user).call{value: transferAmount}(\"\");\n            require(success, \"LineFutures: transfer failed\");\n        }\n        // If finalAmount <= 0, user lost entire deposit (stays in contract)\n\n        emit PositionClosed(\n            _positionId,\n            position.user,\n            _pnl,\n            transferAmount,\n            _actualPriceCommitmentId,\n            block.timestamp\n        );\n    }\n\n    /**\n     * @notice Set the PnL server address\n     * @param _server New PnL server address\n     */\n    function setPnLServer(address _server) external onlyOwner {\n        require(_server != address(0), \"LineFutures: new server is zero address\");\n        address oldServer = pnlServer;\n        pnlServer = _server;\n        emit PnLServerUpdated(oldServer, _server);\n    }\n\n    /**\n     * @notice Set the fee percentage\n     * @param _feePercentage New fee percentage in basis points (max 1000 = 10%)\n     */\n    function setFeePercentage(uint256 _feePercentage) external onlyOwner {\n        require(_feePercentage <= 1000, \"LineFutures: fee too high\");\n        uint256 oldFee = feePercentage;\n        feePercentage = _feePercentage;\n        emit FeePercentageUpdated(oldFee, _feePercentage);\n    }\n\n    /**\n     * @notice Withdraw collected fees\n     * @param _amount Amount to withdraw\n     */\n    function withdrawFees(uint256 _amount) external onlyOwner {\n        require(_amount <= collectedFees, \"LineFutures: insufficient fees\");\n        collectedFees -= _amount;\n        \n        (bool success, ) = payable(owner).call{value: _amount}(\"\");\n        require(success, \"LineFutures: withdrawal failed\");\n        \n        emit FeesWithdrawn(owner, _amount, block.timestamp);\n    }\n\n    /**\n     * @notice Pause the contract (prevents new positions)\n     */\n    function pause() external onlyOwner {\n        paused = true;\n        emit ContractPaused();\n    }\n\n    /**\n     * @notice Unpause the contract\n     */\n    function unpause() external onlyOwner {\n        paused = false;\n        emit ContractUnpaused();\n    }\n\n    /**\n     * @notice Emergency withdraw all funds (last resort)\n     */\n    function emergencyWithdraw() external onlyOwner {\n        uint256 balance = address(this).balance;\n        (bool success, ) = payable(owner).call{value: balance}(\"\");\n        require(success, \"LineFutures: emergency withdrawal failed\");\n    }\n\n    /**\n     * @notice Get position details\n     * @param _positionId Position ID\n     * @return Position struct\n     */\n    function getPosition(uint256 _positionId) external view returns (Position memory) {\n        require(_positionId < positionCounter, \"LineFutures: position does not exist\");\n        return positions[_positionId];\n    }\n\n    /**\n     * @notice Get all position IDs for a user\n     * @param _user User address\n     * @return Array of position IDs\n     */\n    function getUserPositions(address _user) external view returns (uint256[] memory) {\n        return userPositions[_user];\n    }\n\n    /**\n     * @notice Check if a position can be closed\n     * @param _positionId Position ID\n     * @return True if position can be closed\n     */\n    function canClosePosition(uint256 _positionId) external view returns (bool) {\n        if (_positionId >= positionCounter) return false;\n        \n        Position storage position = positions[_positionId];\n        \n        return position.isOpen && \n               block.timestamp >= position.openTimestamp + POSITION_DURATION;\n    }\n\n    /**\n     * @notice Get contract balance\n     * @return Contract ETH balance\n     */\n    function getContractBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n\n    /**\n     * @notice Get user statistics\n     * @param _user User address\n     * @return totalPositions Total number of positions\n     * @return openPositions Number of open positions\n     * @return closedPositions Number of closed positions\n     * @return totalPnl Total PNL across all positions\n     */\n    function getUserStats(address _user) external view returns (\n        uint256 totalPositions,\n        uint256 openPositions,\n        uint256 closedPositions,\n        int256 totalPnl\n    ) {\n        uint256[] memory userPosIds = userPositions[_user];\n        totalPositions = userPosIds.length;\n        \n        for (uint256 i = 0; i < userPosIds.length; i++) {\n            Position storage pos = positions[userPosIds[i]];\n            if (pos.isOpen) {\n                openPositions++;\n            } else {\n                closedPositions++;\n                totalPnl += pos.pnl;\n            }\n        }\n        \n        return (totalPositions, openPositions, closedPositions, totalPnl);\n    }\n}\n\n"
      }
    }
  }
}