{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-3630c64270f7151b9b7bb475830dd958813bc3ce",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/PriceOracle.sol": "project/contracts/PriceOracle.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "optimizer": {
        "enabled": true,
        "runs": 200
      },
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": []
    },
    "sources": {
      "project/contracts/PriceOracle.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.28;\n\n/**\n * @title PriceOracle\n * @notice Stores EigenDA commitment strings for token pair price data windows\n * @dev Each commitment represents a 60-second price window stored in EigenDA\n */\ncontract PriceOracle {\n    // Mapping from window start timestamp to EigenDA commitment string\n    mapping(uint256 => string) public priceCommitments;\n    \n    // Mapping from window start timestamp to block timestamp when commitment was stored\n    mapping(uint256 => uint256) public commitmentTimestamps;\n    \n    // Array of all window timestamps for iteration\n    uint256[] public windowTimestamps;\n    \n    // Mapping to check if a window timestamp already exists\n    mapping(uint256 => bool) private windowExists;\n    \n    // Address authorized to submit commitments\n    address public submitter;\n    \n    // Contract owner for administrative functions\n    address public owner;\n    \n    // Events\n    event CommitmentStored(\n        uint256 indexed windowStart,\n        string commitment,\n        uint256 timestamp\n    );\n    \n    event SubmitterUpdated(\n        address indexed oldSubmitter,\n        address indexed newSubmitter\n    );\n    \n    event OwnershipTransferred(\n        address indexed previousOwner,\n        address indexed newOwner\n    );\n    \n    // Modifiers\n    modifier onlySubmitter() {\n        require(msg.sender == submitter, \"PriceOracle: caller is not the submitter\");\n        _;\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"PriceOracle: caller is not the owner\");\n        _;\n    }\n    \n    /**\n     * @notice Constructor sets the initial submitter and owner\n     * @param _submitter Address authorized to submit commitments\n     */\n    constructor(address _submitter) {\n        require(_submitter != address(0), \"PriceOracle: submitter is zero address\");\n        submitter = _submitter;\n        owner = msg.sender;\n        \n        emit SubmitterUpdated(address(0), _submitter);\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n    \n    /**\n     * @notice Store a commitment string for a price window\n     * @param windowStart Unix timestamp of the window start (minute boundary)\n     * @param commitment EigenDA commitment string\n     */\n    function storeCommitment(uint256 windowStart, string memory commitment) external onlySubmitter {\n        require(bytes(commitment).length > 0, \"PriceOracle: commitment is empty\");\n        require(windowStart > 0, \"PriceOracle: invalid window start\");\n        require(windowStart % 60 == 0, \"PriceOracle: window start must be minute boundary\");\n        \n        // Store the commitment\n        priceCommitments[windowStart] = commitment;\n        commitmentTimestamps[windowStart] = block.timestamp;\n        \n        // Add to window timestamps array if not already present\n        if (!windowExists[windowStart]) {\n            windowTimestamps.push(windowStart);\n            windowExists[windowStart] = true;\n        }\n        \n        emit CommitmentStored(windowStart, commitment, block.timestamp);\n    }\n    \n    /**\n     * @notice Get the commitment string for a specific window\n     * @param windowStart Unix timestamp of the window start\n     * @return commitment The EigenDA commitment string\n     */\n    function getCommitment(uint256 windowStart) external view returns (string memory) {\n        return priceCommitments[windowStart];\n    }\n    \n    /**\n     * @notice Get the latest window timestamp\n     * @return Latest window start timestamp, or 0 if no windows stored\n     */\n    function getLatestWindow() external view returns (uint256) {\n        if (windowTimestamps.length == 0) {\n            return 0;\n        }\n        return windowTimestamps[windowTimestamps.length - 1];\n    }\n    \n    /**\n     * @notice Get all window timestamps in a time range\n     * @param start Start of the time range (inclusive)\n     * @param end End of the time range (inclusive)\n     * @return windows Array of window timestamps in the range\n     */\n    function getWindowsInRange(uint256 start, uint256 end) external view returns (uint256[] memory) {\n        require(start <= end, \"PriceOracle: invalid range\");\n        \n        // First pass: count matching windows\n        uint256 count = 0;\n        for (uint256 i = 0; i < windowTimestamps.length; i++) {\n            if (windowTimestamps[i] >= start && windowTimestamps[i] <= end) {\n                count++;\n            }\n        }\n        \n        // Second pass: collect matching windows\n        uint256[] memory windows = new uint256[](count);\n        uint256 index = 0;\n        for (uint256 i = 0; i < windowTimestamps.length; i++) {\n            if (windowTimestamps[i] >= start && windowTimestamps[i] <= end) {\n                windows[index] = windowTimestamps[i];\n                index++;\n            }\n        }\n        \n        return windows;\n    }\n    \n    /**\n     * @notice Get the total number of stored windows\n     * @return Total count of windows\n     */\n    function getWindowCount() external view returns (uint256) {\n        return windowTimestamps.length;\n    }\n    \n    /**\n     * @notice Update the authorized submitter address\n     * @param newSubmitter New submitter address\n     */\n    function updateSubmitter(address newSubmitter) external onlyOwner {\n        require(newSubmitter != address(0), \"PriceOracle: new submitter is zero address\");\n        address oldSubmitter = submitter;\n        submitter = newSubmitter;\n        emit SubmitterUpdated(oldSubmitter, newSubmitter);\n    }\n    \n    /**\n     * @notice Transfer ownership of the contract\n     * @param newOwner New owner address\n     */\n    function transferOwnership(address newOwner) external onlyOwner {\n        require(newOwner != address(0), \"PriceOracle: new owner is zero address\");\n        address oldOwner = owner;\n        owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n\n"
      }
    }
  }
}